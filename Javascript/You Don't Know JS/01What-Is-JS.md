# Chapter 1 자바스크립트란 무엇인가

## The Web Rules Everything About JS

JS의 실행 환경은 브라우저, 서버, 로봇 등으로 확장되고 있지만 웹이 제일 지배적이다 그러므로 웹 브라우저에서 JS가 어떻게 구현되는지가 중요하다

대부분의 경우 스펙에 정의된 JS와 브라우저 기반 JS엔진에서 실행되는 JS는 동일하다 그러나 정확히 일치하지 않는 경우가 있으므로 주의해야한다

```

alert("Hello, JS!");

```

이 코드는 JS 프로그램인가?

JS 스펙에는 포함되지 않지만 웹 JS 환경에서는 포함한다

다양한 JS 환경에서(JS 엔진 브라우저, node.js 등) 사용자 브라우저에 `alert` 같은 특수한 기능을 제공 하는것과 같이 JS프로그램의 전체 범위에 API들을 추가한다

사실 넓은 범위의 JS-탐색 API들(`fetch(...)`, `getCurrentLocation(..)`, `getUserMedia(...)`)들은 모두 JS처럼 보이는 Web API이다 Node.js에서는 다양한 Built-in modules로 부터 `fs.write(...)`같은 많은 API 메소드에 접근할 수 있다.

또 다른 일반적인 예로는 `console.log(...)`이다. 마찬가지로 JS에 명시되어 있지 않지만 유용하기 때문에 거의 모든 JS 환경에서 사용이 가능하다

그러므로 `alert(...)`나 `console.log(...)`는 JS에 의해서 정의되지 않았지많 JS처럼 보인다. JS엔진을 실행하는 환경에서 제어가 되지만 기본적으로 JS 문법 규칙을 따른다

사람들이 JS에 일관성이 없다는 주장은 실제로 JS 자체의 작동 방식이 아닌 다른 환경과 그 환경이 동작하는 방식에 따른 것이다.

그래서 `alert(...)`은 JS라고 부를 수는 있지만 공식적인 JS 스펙이 아니라 손님이다

## It's Not Always JS

console/REPL(Read-Evaluate-Print-Loop)를 브라우저의 개발자도구에서 사용하는 것은 간단한 JS 환경으로 보이지만 그렇지 않다

개발자 도구는 개발자를 위한 도구이다 주된 목적은 개발자들이 수월하게 일하는 것을 도와주는 것이다 개발자의 경험을 우선시 하는 것이지 JS 동작의 모든 것을 정확하게 반영하는 것이 목표가 아니다

따라서 작동방식이 브라우저마다 다르다 하지만 이런 점이 네이티브 JS 동작을 가정하지 않는 것을 보여준다

1. `var`나 `function`이 콘솔의 global scope에서 선언 됐을 때, 실제로 전역변수로 생성이 되는지

2. 최상위 Global scope에서 다중 let, const 선언으로 발생하는 상황

3. `"use strict";`를 one line-entry에서 사용했을때, 나머지 콘솔 세션에서도 strict 모드가 적용이 되는지

4. non-strict 모드에서 `this` 기본 바인딩이 함수 호출에 작동하는 방식과 사용된 Global scope에 예상 전역변수가 포함되는지 여부

5. multiple line entries에서 호이스팅이 어떻게 동작하는지

개발자 콘솔은 개발자가 빠르게 결과를 확인할 수 있도록 도와주는 것이지 .js파일을 처리하는 것과 정확히 동작하는 JS Compiler가 아니다

## Many Faces

'패러다임'이라는 용어는 프로그래밍에서 코드 구성에 대한 광범위한 사고 방식과 접근 방식을 의미한다 패러다임 내에서는 프로그램을 드러내는 수 많은 스타일과 형식이 존재한다

그러나 프로그램마다 스타일이 뭐가 됐던 패러다임 주위의 큰 그림 구별은 거의 한 눈에 알 수 있다

일반적으로 패러다임 수준 코드 범주에는 절차지향, 객체지향, 함수형이 존재한다

1. 절차지향은 일반적으로 top-down형식으로 코드가 구성되고 사전에 결정된 작업을 통해서 선형적으로 진행된다

2. 객체지향은 클래스라고 불리는 단위로 로직과 데이터를 수집하여 구성한다

3. 함수형은 함수 안에 코드를 구성하고(절차가 아닌 순수 계산) 함수를 값으로 적용한다

패러다임들에 옳고 그른것은 없다 패러다임들은 프로그래머들이 문제에 접근하고 해결하는 방법, 코드를 구성하고 유지하는 방법을 형성하기 위한 방법이다

일부 언어는 하나의 패러다임으로 크게 기울어져 있지만 JS는 다중 패러디임 언어이다. 절차지향, 객체 지향, 함수형 모두 작성할 수 있다

## Jumping The Gaps

JS는 상위호환이 아니기 때문에 유효한 JS로 작성할 수 있는 코드와 사이트 혹은 어플리케이션이 오래된 엔진과 차이가 있을 수 있다 예를 들어 내 프로그램이 ES2019를 사용하는데 엔진이 2016이라면 프로그램이 깨질것이다

만약에 기능이 새로운 구문인 경우 프로그램은 일반적으로 컴파일 및 실행을 실패해서 구문 오류를 발생한다

따라서 JS 개발자가 이 문제를 해결하기 위해 주의를 기울여야한다

호환되지 않는 새로운 구문은 transpiller(일반적으로 Babel일 많이 사용된다)를 사용해서 호환성 문제를 해결한다

```
if(something){
    let x = 3;
    console.log(x);
}
else{
    let x = 4;
    console.log(x);
}
```

개발자가 이런 코드를 작성했다면

바벨은 코드를 이런식으로 변환한 뒤, 웹 사이트에 배포할 파일을 생성한다

```
var x$0;
var x$1;

if(something){
    x$0 = 3;
    console.log(x$0);
}
else{
    x$1 = 4;
    console.log(x$1);
}
```

원래 스니펫(재사용 가능한 소스코드)은 let에 의존하는데 변수 x가 if else 구문에서 서로 간섭하지 않게 블록 범위를 형성한다

이 프로그램을 바벨은 두개의 다른 유일한 변수를 생성해서 다른 서로 간섭하지 않는 코드로 변환한다

여기서 궁금증 : 왜 최신버전 코드를 구 버전 코드로 바꾸려고 애를 쓸까? 그냥 `let`을 안쓰고 변수 두 개 쓰면 되는거 아닌가? 그 이유는 최신버전 JS 코드를 사용하는게 깔끔하고 소통이 잘 이루어지기 때문에 최신버전 코드를 사용하는 것을 권장한다

개발자는 새로운 구문을 사용해서 깔끔하게 코드를 작성하는데 집중하고 바벨과 같은 도구를 이용해서 변환해야한다.

## Filling The Gaps

만약에 상위호환성 문제가 새로운 구문과 관련된 것이 아니고 최근에 추가된 API 메소드를 추가하지 않은 것이라면 가장 흔한 해결방법이 추가되지 않은 API 메소드를 정의 해주는 것이다. 이러한 패턴을 polyfill(aka "shim")이라고 한다

이 코드를 보자

```
// getSomeRecords()는 어떤 것에 대해 Promise로 반환한다
// data는 fetch를 통해 가져온다
var pr = getSomeRecords();

//데이터를 가져올 때 spinner가 돈다
startSpinner();

pr
.then(renderRecords) // 성공하면 렌더링
.catch(showError) // 실패하면 에러출력
.finally(hideSpinner) // 언제나 spinner는 숨김
```

이 코드는 ES2019의 기능이 사용되었다 `finally(...)` 만약에 이 코드가 ES2019 이전 환경에서 사용된다면 `finally(...)` 메소드는 에러를 출력할 것이다

`finally(...)`에 대한 기본적인 polyfill은 아래와 같이 된다

```
if (!Promise.prototype.finally){
    Promise.prototype.finally = function f(fn){
        return this.then(fn,fn)
    }
}
```

이 코드에서 `if`문은 JS 엔진이 이미 메소드를 정의한 환경에서 구동 될 때, polyfill이 해당 메소드를 정의하지 못하게 하고 보호하려고 사용한다

Babel과 같은 Transpiller들은 일반적으로 어떤 polyfill이 필요한지 감지하고 제공하는 것을 자동으로 해준다 하지만 때때로 정의나 포함을 시켜줘야한다

아이디어와 의도를 효과적으로 전달하기 위해 항상 가장 적합한 기능을 사용하여 코드를 작성해야한다 이것이 안정적인 최신 JS버전을 사용하는 것이다

문법이나 API Gap을 맘대로 조절해서 코드의 가독성에 영향을 미치면 안된다

Transpilation과 polyfilling은 오래된 환경에서 최신 코드를 돌리는 효과적인 방법이다. 그리고 JS는 계속 업데이트가 되고 있기 때문에 JS 프로젝트에 반드시 포함되는 과정이 될 것이다

## What's In an Interpretation?

JS에서 가장 큰 논쟁거리가 "interpreted script인가 compiled program이가" 이다. 가장 주된 의견은 interpred(scripting) 언어라는 것이다 하지만 그것보다 더 복잡하다

오랜기간동안 "Interpreted" 언어와 "Scripting" 언어는 "compiled" 언어에 비해 열등한 언어라고 여겨졌다 이런 인식에 대한 이유는 다양하다.

성능 최적화 부족에 대한 인식을 포함해서 scripting 언어 같이 일반적으로 "더 성숙한" 정적 타입 언어 대신 동적 타입을 사용하는 특정 언어의 특성을 선호하지 않는다

"compiled" 언어는 일반적으로 나중에 프로그램을 실행하기 위해서 프로그램의 이식 가능한 상태(binary) 형태를 생성한다 JS를 사용하여 이러한 종류의 모델을 실제로 관찰하지 않기 때문에 바이너리 형식이 아닌 소스코드를 배포한다

실제로 프로그램의 "실행 가능" 형태에 대한 배포 모델은 지난 수십년 동안 다양해지고 관련성이 떨어졌다 그것은 프로그램이 어떤 형태로 전달되는지 중요하지 않아졌다라는 문제에 도달했다

이러한 잘못된 주장과 비판은 치워두고 JS가 interpreted 인지 compiled인지에 대한 명확한 그림을 가져야 하는 이유는 오류 처리 방법과 관련있다

역사적으로 scripted와 interpreted 언어는 일반적으로 top-down형식 및 라인별 실행이 되었다 그리고 일반적으로 처음에 실행이 시작되기 전에 프로그램에서 프로세스로 통과하지 않는다

scripted와 interpreted 언어에서 5번 라인에 에러가 발생했다면 프로그램이 실행되는 동안 1 ~ 4번 라인까지 발견되지 않는다

5번 라인에서의 에러는 어떤 변수나 값이 적절하지 않은 값을 갖는 런타임 조건에서 일어날 수도 있고 잘못된 절이나 명령에 의해 일어날 수도 있다

상황에 따라 오류 처리 라인에 대한 처리를 연기하는 것이 바람직하거나 바람직하지 않은 영향을 줄 수 있다
