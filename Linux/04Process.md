# Process

SSD, HDD : Storage

RAM : Random access memory(Memory)

CPU : 중앙 처리 장치, Processor(Process와 다름)

Storage와 Memory의 공통점 : 어떤 정보를 저장한다

가격면에서 storage는 저렴(저장용량 큼)하지만 memory는 비싸다(저장용량 작음)

속도면에서는 storage는 느리고 memory는 빠르다

따라서 storage는 cpu의 처리속도를 따라오지 못한다

속도에 대한 문제점을 memory를 활용하여 해결한다

storage에 존재하는 프로그램을 사용하려면 memory에 적재한다(사용하지 않는 프로그램은 뺀다)

memory에 프로그램이 올라오면 cpu는 읽어서 동작한 다음 데이터를 처리한다

정리를 해보자면

mkdir이라는 프로그램(명령어)를 실행할 때, mkdir이란 프로그램은 /bin/mkdir 이라는 storage에 존재한다

storage에서 프로그램을 꺼내 memory에 적재한 뒤, processor인 cpu가 처리를 한다.

## Process Monitering

일반적으로 리눅스에서 돌아가는 프로세스들을 관찰하기 위해서 `ps` 명령어를 사용한다

백그라운드에서 돌아가는 다양한 프로세스를 알기 위해서는 `ps aux`를 입력하게되면 많은 프로세스들이 나열된다

결과로 나온 많은 프로세스중에서 특정 프로세스(apache)를 찾는 방법은 `ps aux | grep apache`를 입력하면 해당 결과값을 출력해준다

(grep은 입력으로 전달된 파일의 내용에서 특정 문자열을 찾고자할 때 사용하는 명령어이다.)

> ps aux의 결과값을 파이프( | )로 입력을 받아서 apache가 들어간 프로세스를 찾는다(grep)

이후 결과로 나온 정보들을 바탕으로(pid(프로세스 id) 등) 프로세스를 관리할 수 있다

ex) `sudo kill (pid)`를 통해서 문제가 있는 프로세스를 종료시킬 수 있다.

ps 외에도 top, htop으로 프로세스 모니터링이 가능하다

> htop을 실행 했을때 나오는 정보
>
> PID : 프로세스의 ID 번호
>
> USER : 프로세스의 소유자
>
> PR : 프로세스의 우선순위
>
> NI : 우선순위에 영향을 주는 프로세스의 nice 값
>
> VIRT : 프로세스가 사용중인 가상 메모리 양
>
> RES : 프로세스가 사용중인 물리 RAM의 양 (단위는 킬로바이트)
>
> SHR : 프로세스가 사용중인 공유 메모리 양
>
> S : 프로세스의 현재 상태(zombied, sleeping, running,
> uninterruptedly sleeping, traced)
>
> %CPU : 프로세스가 프로세서를 사용한 시간의 사용율
>
> %MEM : 프로세스가 사용중인 RAM의 사용율
>
> TIMR+ : 프로세서를 사용한 시간
>
> COMMAND : 프로세스를 시작하도록 한 명령어

## Background Execute

일반적으로 우리가 창을 두 개 이상 사용해서 작업을 할 때 이것을 멀티 태스킹이라고 한다.

뒤에 있는 프로그램을 백그라운드 프로그램

앞에서 진행되는 프로그램은 포그라운드 프로그램

이러한 처리를 리눅스에서도 가능하다

1. `vim` 명령어로 에디터를 실행해준다.

2. 현재 포그라운드 프로그램은 vim이며 백그라운드로 돌리기 위해서 `control + z` 를 눌러준다

> [1] +suspended vim 이라고 출력이 된다

(여러 프로그램을 실행하면 +와 -가 붙은 것을 확인할 수 있는데 + 는 fg를 입력했을 때, 포그라운드로 넘어올 프로그램을 나타내고 -는 그 다음 순서이다.)

vim을 백그라운드로 돌렸고 다른 명령을 실행할 수 있는 상태가 되었다

3. 백그라운드에 존재하는 프로그램을 보기 위해서 `jobs` 명령어로 확인이 가능하다

4. `fg` 명령어를 통해서 백그라운드 프로그램을 불러온다

5. `:qa!`를 입력해서 정상적으로 vim을 종료시킨다 (kill %프로그램 숫자를 입력해서 종료 가능 만약 안된다면 파라미터로 -9 를 넣어주면 된다)

6. `jobs`를 입력하면 백그라운드 프로그램이 없는 것을 확인할 수 있다

> fg %프로그램 숫자 를 입력해서 해당 번호의 프로그램을 포그라운드로 불러올 수 있다

## 바로 백그라운드로 보내기

`ls -alR / > result.txt 2> error.txt` 명령어를 실행한다면

루트 디렉토리 아래에 존재하는 모든 파일들의 상태와 에러를 저장하게 된다.

작업량이 상당해서 터미널이 멈추는 현상을 볼 수 있다. 이렇게 되면 다른 작업을 수행 할 수 없고 시간만 날리는 것이다

따라서 실행과 동시에 백그라운드로 날려버리면서 우리는 포그라운드에서 다른 작업을 수행하게 된다.

`ls -alR / > result.txt 2> error.txt &`로 &를 붙여주면 실행과 동시에 백그라운드로 넘어가는 것을 확인할 수 있다.

입력한뒤 `jobs` 명령어를 입력하면 백그라운드에서 우리가 입력한 명령어가 running 상태로 존재한다.

## daemon의 개념

프로그램은 항상 실행되는것과 필요할 때만 실행되는 것이 있다.

그 예로 ls, mkdir, rm 등 우리의 필요에 의해 그 순간만 실행이 된다.

항상 실행되는 것은 클라이언트의 요구에 응답하기 위해서 항상 켜져있는 웹서버를 그 예로 들 수 있겠다

비유를 하자면 웹서버는 냉장고, 명령어는 TV 정도로 생각하면 이해가 될 것이다.

## CRON

정기적으로 명령을 실행시켜주는 도구

`crontab -e` 이라는 명령어를 통해서 정기적으로 실행하는 루틴을 만들 수 있도록 에디터로 진입을 하게 된다

1. `crontab -e`으로 에디터로 들어간다

2. 조건을 입력해준다 ~분 ~시간 한달에 몇번 등 여러 조건이 있다

3. 해당 조건에 따른 command를 입력해준다

> ex) _/1 _ \* \* \* date >> date.log
>
> 1분마다 data 명령어를 실행해서 date.log에 계속해서 추가해준다

4. 저장 후, `crontab -l`을 통해서 명령들을 확인할 수 있다

## 쉘을 시작할 때 실행

> alias (별명) : 어떤 명령에 별명을 붙여줘서 별명으로 해당 명령을 실행할 수 있다
>
> `ex) alias l='ls -al'`입력하면 l 을 입력할 때마다 `ls -al`명령을 실행하게 된다.

쉘이 시작될 때 실행되는 명령을 넣고 싶다면

bash를 사용한다면 .bashrc zsh를 사용한다면 .zshrc를 편집해서 사용할 수 있다

`nano .zshrc`를 입력하면 편집기로 들어가게 되고

`echo hello zsh` 를 저장하고 zsh를 다시 실행하면 hello zsh가 출력되는 것을 확인할 수 있다. 이걸 활용해서 여러 편리한 기능을 생성할 수 있다.
